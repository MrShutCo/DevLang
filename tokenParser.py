from tokens import *
from grammar import *


class Parser():
    def __init__(self, tokens):
        # The list of tokens generated by the lexer
        self.tokens = tokens

    def raise_error(self, token):
        raise Exception(
            "Parser error at {}.\nType: {}\nValue: {}"
            .format(token.loc, token.type, token.value))

    # See if the next token has the correct type
    def eat(self, type_token):
        token = self.peek()
        if token.type == type_token:
            return self.next()
        else:
            print(token)
            self.raise_error(token)

    # Token must match at least one of the types
    def eat_any(self, type_tokens):
        token = self.peek()
        if token.type in type_tokens:
            return self.next()
        else:
            self.raise_error(token)

    # Pops a token from the stack (from the end of the list)
    def next(self):
        return self.tokens.pop()

    # Inserts token back into the stack (at the end of the list)
    def push(self, token):
        self.tokens.append(token)

    # Gets the next token without removing it from the list
    def peek(self):
        return self.tokens[-1]

    # Gets the last n tokens
    def peek_many(self, n):
        return list(reversed(self.tokens[-n:]))

    # TODO: Operator precedence
    #       Parser combinators
    def parse_AExpr(self):

        left = None
        tk = self.peek()
        if tk.type == Special.OpenBracket: # If we encounter an open bracket
            self.next()
            expr = self.parse_AExpr()       # The brackets enclose an expression
            self.eat(Special.CloseBracket) # It should end with a closing bracket
            left = ABrackets(expr)
        elif tk.type == Type.Integer: 
            left = self.next()
            tk = self.peek()
            if self.is_operator(tk.type):  # Integer can be part of another expression
                self.next()
                op = tk.type
                right = self.parse_AExpr() # For now we don't care what is on the rhs
                left = ABinaryOp(op, AConstant(left.value), right)
            else:
                 left = AConstant(left.value)
        
        tk = self.peek()
        if self.is_operator(tk.type):  # left can be part of some outer expression
            self.next()
            op = tk.type
            right = self.parse_AExpr()
            return ABinaryOp(op, left, right)
        else:
            return left

    def is_operator(self, type_token):
        return type_token in [Operator.Add, Operator.Subtract,
                              Operator.Divide, Operator.Multiply]

    def parse(self):
        # print(self.tokens, "\n")

        print(self.parse_AExpr())
