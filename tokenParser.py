from tokens import *


class ExpressionTypes(Enum):
    Integer = 0
    Addition = 1
    Subtraction = 2
    Brackets = 3
    Root = 4


class Expression():
    def __init__(self, int=None):
        self.children = []
        if type(int) == type(1):
            self.type = ExpressionTypes.Integer
            self.children = [int]

    def __repr__(self):
        return str(self.type)+": "+str(self.children)

    def __str__(self):
        return str(self.type)+": "+str(self.children)

class Parser():
    def __init__(self, tokens):
        # The list of tokens generated by the lexer
        self.tokens = tokens

    def raise_error(self, token):
        raise Exception("Ohnoes, an error occurred at position {}.\nType: {}\nValue: {}".format(token.loc, token.type, token.value))

    # See if the next token has the correct type
    def eat(self, type_token):
        token = self.peek()
        if token.type == type_token:
            return self.next()
        else:
            self.raise_error(token)

    # Token must match at least one of the types
    def eat_any(self, type_tokens):
        token = self.peek()
        if token.type in type_tokens:
            return self.next()
        else:
            self.raise_error(token)

    # Pops a token from the stack (from the end of the list)
    def next(self):
        return self.tokens.pop()

    # Inserts token back into the stack (at the end of the list)
    def push(self, token):
        self.tokens.append(token)

    # Gets the next token without removing it from the list
    def peek(self):
        return self.tokens[-1]

    # Gets the last n tokens
    def peek_many(self, n):
        return list(reversed(self.tokens[-n:]))

    # returns an Expression (aka a tree)
    # NEEDS IMPROVEMENT
    # Does not handle invalid input properly
    # Can't add 3 things for example 1+2+3
    def parseExpression(self):
        node = Expression();
        node.type = ExpressionTypes.Root

        x = self.eat_any([Special.OpenBracket, Type.Integer])
        if x.type == Special.OpenBracket:
            node.children.append(self.parseExpression())
            x = self.eat_any([Operator.Add, Operator.Subtract, Special.EOF, Special.Delimiter, Special.CloseBracket])
            if x.type in [Special.EOF, Special.Delimiter]:
                return node.children[0]
            elif x.type == Special.CloseBracket:
                if self.peek().type in [Operator.Add, Operator.Subtract]:
                    x = self.next()
                else:
                    return node.children[0]
            if x.type == Operator.Add:
                node.type = ExpressionTypes.Addition
                node.children.append(self.parseExpression())
            else:
                node.type = ExpressionTypes.Subtraction
                node.children.append(self.parseExpression())
            return node
        else: # x is an Integer
            if self.peek().type in [Special.EOF, Special.Delimiter, Special.CloseBracket]:
                return Expression(int(x.value))
            node.children.append(Expression(int(x.value)))
            x = self.eat_any([Operator.Add, Operator.Subtract])
            if x.type == Operator.Add:
                node.type = ExpressionTypes.Addition
                if self.peek().type == Type.Integer:
                    x = self.next()
                    node.children.append(Expression(int(x.value)))
                else:
                    node.children.append(self.parseExpression())
                return node
            else:
                node.type = ExpressionTypes.Subtraction
                if self.peek().type == Type.Integer:
                    x = self.next()
                    node.children.append(Expression(int(x.value)))
                else:
                    node.children.append(self.parseExpression())
                return node


    def parse(self):
        # print(self.tokens, "\n")

        print(self.parseExpression())
